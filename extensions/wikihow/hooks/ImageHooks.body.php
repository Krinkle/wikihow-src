<?php

if ( !defined('MEDIAWIKI') ) exit;

class ImageHooks {

	// AG - method signature changed due to how to check if file exists in lastest MW
	static function onImageConvertNoScale($image, $params) {

		// edge case...if the image will not actually get watermarked because it's too small, just return true
		if (WatermarkSupport::validImageSize($params['physicalWidth'], $params['physicalHeight']) == false) {
			return true;
		}

		// return false here..we want to create the watermarked file!
		// AG - TODO trying to figure out why we check if the file exists here..doesn't 
		// seem necessary or should be inverted
		if ( @$params[WatermarkSupport::ADD_WATERMARK] || $image->getRepo()->fileExists($params['dstPath']) ) {
			return false;
		}

		return true;
	}

	static function onImageConvertComplete($params) {
		global $wgJpegOptimCommand, $wgOptiPngCommand;

		$dstPath = $params['dstPath'];

		// First, add any watermarks to generated image
		if (@$params[WatermarkSupport::ADD_WATERMARK]) {
			WatermarkSupport::addWatermark($dstPath, $dstPath, $params['physicalWidth'], $params['physicalHeight']);
		}

		// Then try to optimize the output image for size while keeping
		// display properties the same by using optipng and jpegoptim
		if (IS_IMAGE_SCALER && @$params['mimeType'] == 'image/jpeg' && $wgJpegOptimCommand) {
			$cmd = wfEscapeShellArg($wgJpegOptimCommand) . " --strip-all " .
				wfEscapeShellArg($dstPath) . " >> /tmp/imgopt.log 2>&1";// . " 2>&1";
			$beforeExists = file_exists($dstPath);
			wfDebug( __METHOD__.": running jpegoptim: $cmd\n");
			$err = wfShellExec( $cmd, $retval );
			$afterExists = file_exists($dstPath);
			$currentDate = `date`;
			// debugging output
			wfErrorLog(trim($currentDate) . " $cmd b:" . ($beforeExists ? 't' : 'f') .
				" a:" . ($afterExists ? 't' : 'f') . " ret:$retval\n", '/tmp/imgopt.log');
		} elseif (IS_IMAGE_SCALER && @$params['mimeType'] == 'image/png' && $wgOptiPngCommand) {
			$cmd = wfEscapeShellArg($wgOptiPngCommand) . " " .
				wfEscapeShellArg($dstPath) . " >> /tmp/imgopt.log 2>&1";// . " 2>&1";
			$beforeExists = file_exists($dstPath);
			wfDebug( __METHOD__.": running jpegoptim: $cmd\n");
			$err = wfShellExec( $cmd, $retval );
			$afterExists = file_exists($dstPath);
			$currentDate = `date`;
			// debugging output
			wfErrorLog(trim($currentDate) . " $cmd b:" . ($beforeExists ? 't' : 'f') .
				" a:" . ($afterExists ? 't' : 'f') . " ret:$retval\n", '/tmp/imgopt.log');
		}

		return true;
	}

	static function onFileTransform($image, &$params) {

		if ( $image->getUser("text") 
			&& WatermarkSupport::isWikihowCreator($image->getUser('text')) 
			&& (!isset($params[WatermarkSupport::NO_WATERMARK]) 
				|| $params[WatermarkSupport::NO_WATERMARK] != true))
		{
			$params[WatermarkSupport::ADD_WATERMARK] = true;
		}

		if (!isset($params[WatermarkSupport::FORCE_TRANSFORM])
			|| $params[WatermarkSupport::FORCE_TRANSFORM] != true)
		{
			return true;
		}

		return false;
	}

	static function onBitmapDoTransformScalerParams($params, &$scalerParams) {
		if ( isset($params[WatermarkSupport::ADD_WATERMARK]) ) {
			 $scalerParams[WatermarkSupport::ADD_WATERMARK] = $params[WatermarkSupport::ADD_WATERMARK];
		}
		return true;
	}

	// AG changed the signature of this method to take the rawParams as well as normalised params
	//  so that we can add the crop to the filename if needed (which uses rawParams)
	static function onFileThumbName($image, $rawParams, $params, &$thumbName) {
		if (!$rawParams) {
			$rawParams = $params;
		}

		if ( $image->getUser('text') 
			&& WatermarkSupport::isWikihowCreator($image->getUser('text')) 
			&& isset($params[WatermarkSupport::NO_WATERMARK])
			&& $params[WatermarkSupport::NO_WATERMARK] == true)
		{
			$wm = 'nowatermark-';
			$thumbName = $image->getHandler()->makeParamString( $params ) . '-' . $wm . $image->getName();
		}

		if (isset($params['crop']) && $params['crop'] == 1) {
			// if the requested width was passed in, we have a thumbnail name where the crop width
			// didn't match the "px" width. The crop width is the one used in generating the image,
			// but we need to reflect the requested "px" width in the URL generated by these functions
			// because it must match the input "canonical" url.
			// Example: /images/thumb/8/87/Manage-Fats-and-Sugars-on-the-Volumetrics-Diet-Step-12.jpg/-crop-342-254-300px-nowatermark-Manage-Fats-and-Sugars-on-the-Volumetrics-Diet-Step-12.jpg
			if (isset($params['reqwidth']) && $params['reqwidth'] > 0) {
				$wm = isset($params[WatermarkSupport::NO_WATERMARK])
					&& $params[WatermarkSupport::NO_WATERMARK]
						? 'nowatermark-'
						: '';
				$thumbName = "-crop-{$rawParams['width']}-{$rawParams['height']}-"
					. "{$params['reqwidth']}px-"
					. $wm . $image->getName();
			} else {
				$thumbName = "-crop-{$rawParams['width']}-{$rawParams['height']}-" . $thumbName;
			}
		}

		return true;
	}

	static function onImageConvert($params) {
		$physicalWidth = $params['physicalWidth'];
		$physicalHeight = $params['physicalHeight'];
		$addWatermark = isset($params[WatermarkSupport::ADD_WATERMARK]) ? $params[WatermarkSupport::ADD_WATERMARK] : '';
		$srcWidth = $params['srcWidth'];
		$srcHeight = $params['srcHeight'];

		if ( $physicalWidth == $srcWidth && $physicalHeight == $srcHeight && $addWatermark ) {
			WatermarkSupport::addWatermark($params['srcPath'], $params['dstPath'], $physicalWidth, $physicalHeight);
			return false;
		}

		return true;
	}

	static function onThumbnailBeforeProduceHTML($thumbnailImage, $attribs, $linkAttribs) {
		if ($attribs && is_array($attribs) && !empty($attribs['src'])) {
			$attribs['src'] = wfGetPad($attribs['src']);
		}
		return true;
	}

	// aaron - linker hook before images are produced
	static function onImageBeforeProduceHTML(&$dummy, &$title, &$file, &$frameParams, &$handlerParams, &$time, &$res) {
		if (!$file) {
			MWDebug::warning("could not load file from title: $title");
			return false;
		}

		return true;
	}

	// Parse the first part of a thumbnail name such as: "670px", "crop-127-100-127px",
	// or "-nowatermark-670px". ImageHooks::onFileThumbName generates these thumbnail
	// prefixes and this method parses them at a later step when they are requested.
	static function onImageHandlerParseParamString($str, &$params) {
		$p = array();
		$parts = explode('-', $str);
		// skip any empty first param because thumbnail prefixes are often "-crop-..."
		if (count($parts) && !$parts[0]) {
			array_shift($parts);
		}
		// check for crop-width-height
		if (count($parts) >= 3 && $parts[0] == 'crop') {
			array_shift($parts);
			$p['crop'] = 1;
			$p['width'] = (int)array_shift($parts);
			$p['height'] = (int)array_shift($parts);
		}
		// check for 670px
		if ( count($parts) && preg_match( '/^(\d+)px$/', $parts[0], $m ) ) {
			array_shift($parts);
			$width = (int)$m[1];
			if (!isset($p['width']) || $p['width'] <= 10) {
				$p['width'] = $width;
			} else {
				$p['reqwidth'] = $width;
			}
			// Note that we take the crop width param to be the correct one if two
			// width params are present. This functionality can be verified by looking
			// at the output image (which is 163px wide) from this partial URL:
			// /images/thumb/c/ca/Default_wikihow_blue.png/-crop-163-119-141px-Default_wikihow_blue.png
		}
		// check for nowatermark
		if (count($parts) && $parts[0] == 'nowatermark') {
			array_shift($parts);
			$p[WatermarkSupport::NO_WATERMARK] = true;
		}

		// if we were able to parse this thumbnail prefix, keep result
		if (count($p)) {
			$params = $p;
		}
		return true;
	}

}

